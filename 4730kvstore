#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random
from enum import Enum
from collections import defaultdict, namedtuple

BROADCAST = "FFFF"
RECV_WAIT = 0.1
SEND_WAIT = 0.01

class State(Enum):
    FOLLOWER = "FOLLOWER"
    CANDIDATE = "CANDIDATE"
    LEADER = "LEADER"

Entry = namedtuple('Entry', ['term', 'key', 'value'])

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others: list[str] = others
        self.leader_id = BROADCAST

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": self.leader_id, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

        self.data = defaultdict(lambda: "")
        self.log: list[Entry] = []
        self.last_log_term = 0
        self.timeout_sec = random.randrange(100, 200)/1000
        self.last_heartbeat = None
        self.state = State.FOLLOWER
        self.term = 0
        self.num_committed = 0
        
        self.voting = False
        self.votedFor = None
        self.votes = None # int

        # leader gets a put
        # leader sends to each replica, replica adds to log as uncommitted and sends OK to leader
        # when quorum, send commit OK 
        # pop from log and commit, add to committed

        # if follower rx an AppendEntry w/ higher commit or log index, send fail and leader will respond w/ one lower 

    def recv(self) -> dict:
        ready = select.select([self.socket], [], [], RECV_WAIT)[0]
        if self.socket in ready:
            buffer = ''
            while '}' not in buffer:
                encoded_data, addr = self.socket.recvfrom(65535)
                buffer += encoded_data.decode('utf-8')
            return json.loads(buffer)

    def send(self, message: dict) -> None:
        ready = select.select([], [self.socket], [], SEND_WAIT)[1]
        if self.socket in ready:
             self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def commit(self):
        entry = self.log[self.num_comitted]
        self.data[entry.key] = entry.value
        self.num_committed += 1

    def start_election(self):
        self.term += 1
        self.votedFor = self.id
        self.votes = 1
        candidate_msg = {
            'src': self.id, 
            'dst': BROADCAST, 
            'leader': BROADCAST, 
            'type': 'RequestVote', 
            'term': self.term, 
            'last_log_index': len(self.log)-1, 
            'last_log_term': self.log[-1].term if self.log else -1,
        }
        self.send(candidate_msg)

    def vote_if_better(self):
        pass    
    
    def parse_msg(self, msg, keys):
        values = []
        for k in keys:
            try:
                values.append(msg[k])
            except:
                raise ValueError(f"key {k} does not exist in {msg}")

        return values

    def get(self, msg):
        try:
            src, dst, mid, key = self.parse_msg(msg, ["src", "dst", "MID", "key"])
        except ValueError:
            fail_message = {"src": dst, "dst": src, "leader": self.leader_id, "type": "fail", "MID": mid}
            return fail_message
        
        if self.leader_id==BROADCAST:
            #ok_message = {"src": dst, "dst": src, "leader": self.leader_id, "type": "ok", "MID": mid ,"value": self.data[key]}
            #return ok_message
            self.start_election()

        if self.id == self.leader_id:
            ok_message = {"src": dst, "dst": src, "leader": self.leader_id, "type": "ok", "MID": mid ,"value": self.data[key]}
            return ok_message
        else:
            redirect_message = {"src": dst, "dst": src, "leader": self.leader_id, "type": "redirect", "MID": mid}
            return redirect_message
        
    def put(self, msg):
        try:
            src, dst, mid, key, value = self.parse_msg(msg, ['src', 'dst', 'MID', 'key', 'value'])
        except ValueError:
            return {"src": dst, "dst": src, "leader": self.leader_id, "type": "fail", "MID": mid}
            
        if self.id == self.leader_id: # if we are the leader...
            self.data[key] = value
            return {'src': dst, 'dst': src, 'leader': self.id, 'MID': mid, 'type': 'ok', 'value': key}
        elif self.leader_id == BROADCAST:
            # TODO wtf do we do here -> redirect broadcast
            self.data[key] = value # TODO this is wrong
            return {'src': dst, 'dst': src, 'leader': self.id, 'MID': mid, 'type': 'ok', 'value': key}
        else:
            return {"src": dst, "dst": src, "leader": self.leader_id, "type": "redirect", "MID": mid, 'key': key, 'value': value}
    
    def requestVoteRPC(self, msg): # note: will never receive this from oneself
        src, dst, leader, term, last_log_index, last_log_term = self.parse_msg(['src', 'dst', 'leader', 'term', 'last_log_index', 'last_log_term'])
        # if term < our term OR log from candidate is outdated
        if(self.state == State.LEADER):
            pass # return heartbeat if we are the leader
        else(term < self.term) or (last_log_term < self.last_log_term) or\
              (last_log_term == self.last_log_term and last_log_index < len(self.log)-1)\
              or self.votedFor:
            pass # vote no
        # vote yes


    def run(self):
        self.last_heartbeat = time.time()
        while True:
            if (time.time() - self.last_heartbeat >= self.timeout_sec) and not self.voting:
                #TODO: if candidate crashes, other replicas must detect it with their timeout
                print(f"Leader has timed out for {self.id}, {time.time()-self.last_heartbeat}")
                self.voting = True
                self.start_election()
            
            msg = self.recv()
            if msg:
                print("Received message '%s'" % (msg,), flush=True)
                [msg_type] = self.parse_msg(msg, ["type"])
                match msg_type:
                    case 'Append':
                        self.last_heartbeat = time.time()
                    case 'RequestVote':
                        pass
                    case 'get':
                        res = self.get(msg) 
                        self.send(res)                   
                    case 'put':
                        res  = self.put(msg)
                        self.send(res)
                    case _:
                        print(f"BADDY TYPE: {msg_type}")
            

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    print(type(args.others), len(args.others))
    replica = Replica(args.port, args.id, args.others)
    replica.run()
